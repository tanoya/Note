# Java 锁的类型
    这里讲的锁是锁的概念分类，而不是每一个锁的类型都有一个对应的JDK类的实现。

#### 主要的类型

##### 1. 公平锁/非公平锁
    ReentrantLock 等实现了Lock接口的类，能够通过构造函数来指定锁的类型是公平锁还是非公平锁。而Synchronized则是非公平锁。公平锁能够通过请求锁的先后关系来控制锁的获取顺序。非公平锁则不会保留这种顺序。非公平锁因为没有线程调度，所以效率更高一些。

##### 2. 可重入锁
    可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
    <p color="red">ReentrantLock</p> 和 <p color="red">Synchronized</p>都是可重入锁。

##### 3. 自旋锁
    在多核处理其中，为了防止运行在不同核心上的线程，在等待一个竞争资源时候的线程切换上下文的时间浪费，会采用自旋的方式占用处理机，不断的循环的请求竞争资源。这是一种防止上下文切换带来的时间浪费。

##### 4. 锁消除
    锁消除是指对运行的代码做逃逸分析，如果不能被其他线程访问到，也就是当前共享变量是线程安全的，那么在互斥代码块加的锁会被jvm给清除掉，防止不必要锁的开销。

##### 5. 锁粗化
    如果我们在一个循环体内给同一个对象加锁，那么jvm会把代码优化为在循环体外部加锁，然后删掉内部加锁的机制，这样可以减少内层多次加锁的开销。

##### 6. 类锁和对象锁
    加在静态方法上的锁称为类锁，加在对象上的锁称为对象锁。类锁和对象锁是两种不同的锁。

##### 7. 偏向锁、轻量级锁、重量级锁
    整个synchronized锁流程如下：
    1.检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁
    2.如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1
    3.如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。
    4. 当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁
    5.如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
    6.如果自旋成功则依然处于轻量级状态。
    7.如果自旋失败，则升级为重量级锁。

    *锁的作用是什么？*

##### 8.悲观锁和乐观锁
    悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
    乐观锁：假定不会发生并发冲突，只在提交操作时检测是否违反数据完整性。（使用版本号或者时间戳来配合实现）

##### 9.共享锁和排它锁
这两种锁相对于事务来讲。

        共享锁：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。
        排它锁：如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。

##### 10. 读写锁
    主要是指ReentrantReadWriteLock锁。 该锁的时候可以继续参考参考。

>http://www.importnew.com/19472.html
[偏向锁的加锁过程](http://xly1981.iteye.com/blog/1766224)

## 偏向锁和轻量级锁和重量级锁的锁竞争过程
每一个线程在准备获取共享资源时： 
第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 
第二步，如果MarkWord不是自己的ThreadId,锁升级（转变为轻量级锁），这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。 
第三步，两个线程都把对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作，把共享对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord, 
第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 
第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 
第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己







