# JAVA GC 详解
*注：* java 相对于C++或者C语言来说，最大的优势可能就是将内存管理交给了虚拟机来管理，进而极大限度的节省了开发者的时间，提高开发效率。一般的开发者可以不用理会JVM堆内存究竟做了什么操作，但是一旦出现了内存泄漏的问题的时候，开发者必须要知道一些JVM的gc原理才能更好的定位和解决问题。

#### GC ROOTS
`python`使用引用计数来标记一个对象的存活状态，但是很容易造成循环引用（循环应用就是假设有两个对象A和B，在对象A中引用了B，在B中引用了A，此时A和B的引用计数最起码都有一个，当这两个对象都没有什么用处的时候，需要被销毁的时候，此时A，B之间的相互引用，导致了两者都不能被gc回收）。 当一个对象的引用计数都为零的时候，才会让jvm来销毁对象。但是在`JAVA` 或者 `C#`中使用 `GC ROOTS`来解决这个问题，如果一个对象和 GC ROOTS 之间没有连接，那么这个对象就可以视作可以回收的对象

`Java`中可以视作`GC ROOTS`的对象的有：

- 虚拟机栈中的引用的对象。
- 方法区中的类静态属性引用的对象。
- 方法区中的常量引用的对象。
- 本地方法栈（JNI）即一般说的Native的引用对象。

#### 垃圾回收算法
##### 标记清除
标记-清除将垃圾回收分为两个阶段：标记阶段和回收阶段。标记阶段首先通过根节点，标记从根节点开始的对象，也就是可达的对象，标记为存活装填。未被标记的对象就被视为未被引用的垃圾对象。在清除阶段清除掉未被标记的对象。标记清除有一个问题就是清除的时候，会产生内存碎片，因为清理的时候，没有进行空间整理。导致了垃圾回收之后的内存空间是不连续的，这样给大对象分配内存的时候会因为分配不到可以使用的内存从而导致`FULL GC`
##### 复制算法
复制算法实际就是对内存管理实现了分区管理。目前最简单的分区方式就是分代管理。此处只讲 `新生代` 的内存分区方式。复制算法将`新生代`分为了两个区，`Eden` 区和`Survivor` 区。而且`Survivor` 区会分为两部分，大小相同。现在来看的话，实现复制算法的数据内存结构分为了三部分，一个`Eden`区和两个大小相同的`Survivor`区。因为新生代的98%的对象都是朝生夕死，因此，在进行内存空间分配的时候，一般默认的大小分配比例是`Eden` : `Survivor` 为 8:1:1。新生代的对象只会占用`Eden`区和一个`Survivor`区。在`gc`的时候，垃圾回收器会将`Eden` 和 `Survivor`区中存活的对象，都复制到那个空闲的`Survivor`中，最后清理掉Eden和刚才用过的Survivor的空间。然后调换两个`Survivor`的角色，完成内存回收。但是也有可能空闲的`Survivor`内存空间不够，此时就要依赖其他内存(这里指老年代)进行分配担保。
##### 标记整理
复制算法适用于存活对象少，垃圾对象多的新生代。像是在老年代这种存活对象多的内存区域，如果使用复制算法来进行来及回收，第一，两个`Survivor`区域内存会很大，浪费内存，而且存活的对象多，导致复制的成本会很高。
标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方3法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。
##### 增量算法
增量算法的基本思想就是垃圾回收和代码执行交替进行。这使得尽可能小的影响到系统业务。但是因为频繁的线程和上下文切换，会使得垃圾回收的整体成本升高。造成系统吞吐量的下降。
#### 垃圾回收器
*注* 垃圾回收器实际就是垃圾回收算法的具体实现。
##### Serial收集器
Serial收集器是最古老的收集器,该收集器在工作的时候会暂停用户的所有进程，即stop the world。到现在为止，它依然是虚拟机运行在client模式下的默认新生代收集器，与其他收集器相比，对于限定在单个CPU的运行环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程收集效率。

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记－整理“算法。
##### ParNew收集器
ParNew收集器是Serial收集器新生代的`多线程`实现,注意在进行垃圾回收的时候依然会`STOP THE WORLD`，只是相比较Serial收集器而言它会运行多条进程进行垃圾回收。
ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。
##### Parallel Scavenge 收集器
Parallel Scavenge 采用的是 `复制算法` 的多线程新生代垃圾回收器。
Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和`标记－整理`算法。因为Serial Old收集器是老年代，且是单线程收集器，因此，即使使用ParNew收集器作为新生代的垃圾回收器，也不会有多少性能的提升，因此，Parallel Old的错线程实现，就显示的尤为重要。在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。
##### CMS 收集器
CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛（老年代收集器）。CMS收集器是基于`标记清除算法`实现的。
它的收集过程分为四个步骤：

 - 初始标记(initial mark)
 - 并发标记(concurrent mark)
 - 重新标记(remark)
 - 并发清除(concurrent sweep)

*注意初始标记和重新标记还是会stop the world，但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。它是老年代收集器*

不过由于CMS收集器是基于标记清除算法实现的，会导致有大量的空间碎片产生，在为大对象分配内存的时候，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前开启一次Full GC。为了解决这个问题，CMS收集器默认提供了一个-XX:+UseCMSCompactAtFullCollection收集开关参数（默认就是开启的)，用于在CMS收集器进行FullGC完开启内存碎片的合并整理过程，内存整理的过程是无法并发的，这样内存碎片问题倒是没有了，不过停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction参数用于设置执行多少次不压缩的FULL GC后跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。

不幸的是，它作为老年代的收集器，却无法与jdk1.4中已经存在的新生代收集器Parallel Scavenge配合工作，所以在jdk1.5中使用cms来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。

*注 由于Native Memory只能通过FullGC回收，所以除非你非常清楚这时真的有必要，否则不要轻易调用System.gc()。此外除了CMS的GC，其实其他针对old gen的回收器都会在对old gen回收的同时回收young gen。*

##### G1收集器
G1收集器是一款面向服务端应用的垃圾收集器。HotSpot团队赋予它的使命是在未来替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：
- 并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。
- 分代收集：和其他收集器一样，分代的概念在G1中依然存在，不过G1不需要其他的垃圾回收器的配合就可以独自管理整个GC堆。
- 空间整合：G1收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次GC。
- 可预测的非停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

*在使用G1收集器时，Java堆的内存布局和其他收集器有很大的差别，它将这个Java堆分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。虽然G1看起来有很多优点，实际上CMS还是主流。*

- 每个对象在坚持过一次Minor GC之后，年龄就会加1，当超过某个数值时就进入老年代。

原文[链接](http://www.importnew.com/26383.html)
