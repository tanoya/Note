# 目录
 - [订单](#order)
 	- [分销订单上传](#order_distribute)
 	- [给易联上传订单数据](#order_uploadDetail)
 	- [订单修改价格](#order_modifyPrice)
 	- [订单的金额字段](#order_money)
 - [商品](#product
 	- [商品类型](#product_specificationTemplate)
 	- [商品档案](#product_archive)
 - [供应商管理](#supplier)
 	- [供应商结算](#supplier_settleAccount)
 	- [供应商订单](#supplier_order)
 - [区域站点](#areaStation)
 	- [区域站点商品](#areaStation_product)
 	- [区域站点订单](#areaStation_order)
 - [接口](#API)
 	- [对外接口注意事项](#API_attention)
 - [play! 框架](#playframework)
 	- [事务](#playframework_transaction)
 	- [数据绑定](#playframework_dataBinding)
 - [angularjs 框架](#angularjs)
 	- [ng-if OR ng-show](#angularjs_ifORshow)

# <div id="order">订单</div>
#### <div id="order_distribute">分销订单上传</div>
分销订单现在仅仅局限于微信商城，在下单的时候会携带分销员信息（wid && shareparentid）给订单数据。提交订单时，会判断当前订单是不是分销订单，如果是，在订单状态为提交时上传该订单的数据。之后订单的状态可能被修改，之后则只修改状态（调用状态修改接口，如果订单改价的时候，要修改订单的价格）
#### <div id="order_uploadDetail">给易联上传订单数据</div>
现在上传订单到会员和分销订单逻辑是一样的，注意修改价格的时候也要重新调用接口，修改已经上传到易联那边的数据。*订单中如果包含邮费，则邮费单独占用一条数据* （上传的过程是将一个订单根据订单子表数据拆成多条数据给易联发送的）
#### <div id="order_modifyPrice"> 订单修改价格</div>
因为目前商城存在分单操作，而且分单操作是在付款之后执行的操作。由于现在订单的改价是可以修改为零，因此，改价为零后其实相当于付款了。因此改价为零后，要看看当前订单是不是需要分单的订单，如果是，则进行分单的操作。
#### <div id="order_money">订单的金额字段</div>
在Order表中 ：fPayMoney 表示当前订单实付，也就是付款的最终金额。里面包含了运费。
fPayMoney = 订单商品总金额 - 优惠券抵扣金额 - 整单有货抵扣金额 - 积分抵扣金额 + 邮费

# <div id="product">商品</div>
#### <div id="product_specificationTemplate">商品类型</div>
 - 商品类型的编辑功能在页面中修改，在该商品类型被其他商品占用了之后，是不允许修改商品类型中的规格。包括规格和规格值。但是在接口中虽然不允许添加规格，但是可以在已经有的规格中添加规格值。
 - 扩展属性是用于商品档案之中，用来表示商品档案的参数
 - 商品订单属性是用于sku中的商品订单属性，在商品档案中均可以修改

#### <div id="product_archive">商品档案</div>
 这里只说一点，实在商品的sku档案数据中。sku档案是需要显示sku的规格值的，但是在数据库的数据表中，sku记录的是规格值id，放在sku表的cSpecIds字段中，使用 `;` 隔开。但是其实还需要将规格值id放到 `ProductSkuSpecItem` 表中。

# <div id="supplier">供应商管理</div>
#### <div id="supplier_settleAccount">供应商结算</div>
目前做的供应商结算都是只能对单个供应商进行结算，就是根据设置在商品档案中的结算比例字段，结算某个供应商所下的订单的总金额和结算金额是多少，然后生成计算单。目前只是做到了管理员线下给某个供货商打款，然后再生成结算单。目前是在订单表中增加了一个结算单号字段，用来记录当前供货商订单是不是已经结算，并且结算单号。
#### <div id="supplier_order">供应商订单</div>
供应商订单叶签其实和商城订单叶签使用的同一个页面，只是在通过url中哪个叶签跳过来的标志，在js中的数据筛选，增加了某些条件筛选了相应的供应商的订单。所以在修改订单页的js文件时，尤其是页面来源的逻辑代码时一定要非常小心。

# <div id="areaStation">区域站点</div>
#### <div id="areaStation_product">区域站点商品</div>
区域站点中的商品适用于全部站点，其实就是使用的是原商品档案。而适用于某个站点则是创建了一个新的站点商品表，该表中保存了站点的库存、价格等。其中还保存了一个外键，指向了商城的商品档案。
#### <div id="areaStation_order">区域站点订单</div>
区域站点订单其实和供货商订单页面一样，和订单页面使用的是同一个页面，因此存在的问题和供货商订单一样，注意判断页面来源逻辑的修改。

# <div id="API">接口</div>
#### <div id="API_attention">对外接口注意事项</div>
商城目前的对外接口实际上分为了两类：
	- 提供给易联使用： 此类接口一般是定制化严重
	- 提供给非易联的第三方使用：此类接口一般是公共服务
因此在处理接口任务的时候，如果是之前的接口，就要注意此时修改的功能是不是给易联或者非易联调用方使用，避免修改的功能影响到易联调用方或者非易联调用方。

# <div id="playframework">play! 框架</div>
#### <div id="playframework_transaction">事务</div>
目前项目在事务处理方式上采用的是play自身的事务管理机制，即在抛出异常返回时回滚数据，有时事务数据也不回滚，需要手动的在异常的地方使用
`JPA.setRollbackOnly();` 回滚数据库事务。一般的业务处理没有问题。因为之前对外的接口都是单条数据处理，此种方式也未尝不可，但是在批处理多数据的时候，如果其中的一条数据异常，不需要回滚整个事务的话，尽量还是建议手动的接管事务。这样数据处理更加有条理。
*示例*
```
try{
	JPA.em(mysql).getTransaction(); // 获取事务
	JPA.startTx(mysql); // 开启事务
	ToDoSometing();
	JPA.closeTx(mysql); // 提交事务
}catch(Exception e){
	JPA.rollbackTx(mysql); // 事务回滚
}
```
因为play是支持多数据库连接，因此 `mysql` 是指对于哪个数据库进行的事务操作。`mysql`具体值是多少，具体参见play application.conf 文件的数据库连接配置项。

#### <div id="playframework_dataBinding">数据绑定</div>
play! 良好的支持了restFull协议。可以自己绑定URL参数到action类的参数中，类似于struts中的值栈。参数可以通过 `GET` 方式的参数格式，但如果是使用 `POST` 方式的话，需要将 `HTTP` 协议的 `Content-Type` 指定为 `application/x-www-form-urlencoded` 才能自动绑定，其中的绑定机制可以参看play源码。

# <div id="angularjs">angularjs 框架</div>
#### <div id="angularjs_ifORshow">ng-if OR ng-show</div>
`ng-if` 在页面渲染阶段会将代码清除掉。会失去数据绑定，就算显示出来，也无法将数据绑定到 `model` 中去。
`if-show` 在页面只是不显示。显示与否根本不会影响数据的绑定机制。